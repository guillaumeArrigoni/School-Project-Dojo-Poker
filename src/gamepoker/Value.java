package gamepoker;

import gamepoker.exception.IncorrectValueException;
import gamepoker.exception.PokerException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * The value of the cards depends on the strength of each card, this is one of the rules of classic poker.
 * There is a hierarchy of cards that determines strength in poker.
 * The best card is the Ace and the worst is the 2, among the 13 of each suit.
 *
 * @author Karim CHARLEUX & Yacine MERIOUA
 */
public class Value implements Comparable<Value> {

    public static final Value DEUX;
    public static final Value TROIS;
    public static final Value QUATRE;
    public static final Value CINQ;
    public static final Value SIX;
    public static final Value SEPT;
    public static final Value HUIT;
    public static final Value NEUF;
    public static final Value DIX;
    public static final Value VALET;
    public static final Value DAME;
    public static final Value ROI;
    public static final Value AS;

    static {
        try {
            DEUX = new Value("2");
            TROIS = new Value("3");
            QUATRE = new Value("4");
            CINQ = new Value("5");
            SIX = new Value("6");
            SEPT = new Value("7");
            HUIT = new Value("8");
            NEUF = new Value("9");
            DIX = new Value("10");
            VALET = new Value("V");
            DAME = new Value("D");
            ROI = new Value("R");
            AS = new Value("A");
        } catch (PokerException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * The name of the value
     */
    private final String name;

    /**
     * Create a value card with a name
     *
     * @param name of the value object
     */
    public Value(String name) throws PokerException {
        if (!validValueName(name)) {
            throw new IncorrectValueException(name);
        }
        this.name = name;
    }

    /**
     * Create a value card with a position between 2-14
     *
     * @param position a int between 2-14
     */
    public Value(int position) throws PokerException {
        if (position < 2 || position > 14) {
            throw new IncorrectValueException();
        }
        //Get name corresponding to the position in AllValues array
        this.name = getAllValues().get(position).getName();
    }

    /**
     * @return The name of current value object
     */
    public String getName() {
        return this.name;
    }

    /**
     * Get the position of the value between 2 and 14 to determine the highest to the lowest value
     *
     * @return The position of current value
     */
    public int getPosition() {
        List<Value> allValues = getAllValues();
        for (int position = 2; position <= allValues.size(); position++) {
            if (allValues.get(position).getName().equals(this.name))
                return position;
        }
        return 0;
    }

    /**
     * Check if the name past in parameter is valid
     *
     * @param name that must be validated
     * @return True if the name is valid or false if not
     */
    private boolean validValueName(String name) {
        return Arrays.asList("2", "3", "4", "5", "6", "7", "8", "9", "10", "V", "D", "R", "A").contains(name);
    }

    /**
     * Overriding equals() to compare two Value objects
     *
     * @param object The Value object to compare to the current Value
     * @return False or true if object is equals to current Value
     */
    @Override
    public boolean equals(Object object) {
        // If the object is compared with itself then return true
        if (object == this) {
            return true;
        }
        // Check if object is an instance of Value or not
        if (!(object instanceof Value)) {
            return false;
        }
        // Typecast object to Value so that we can compare both data
        Value value2 = (Value) object;

        // Compare the data members and return accordingly
        return value2.name.equals(this.name) && value2.getPosition() == this.getPosition();
    }

    /**
     * Convert a value object in a string object to correct display
     *
     * @return the value converted to a string
     */
    @Override
    public String toString() {
        switch (this.name) {
            case "A":
                return "As";
            case "R":
                return "Roi";
            case "D":
                return "Dame";
            case "V":
                return "Valet";
            default:
                return this.name;
        }
    }

    /**
     * Give all possible values of a card in an array
     *
     * @return an ArrayList of all values
     */
    public static List<Value> getAllValues() {
        return new ArrayList<>(Arrays.asList(null, null, DEUX, TROIS, QUATRE, CINQ, SIX, SEPT, HUIT, NEUF, DIX, VALET, DAME, ROI, AS));
    }

    /**
     * @return a unique integer value, generated by a hashing algorithm according to name
     */
    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    /**
     * Compare two Value object based on position
     *
     * @param value the object to be compared.
     * @return -1 = Current < second | 0 = Equal | 1 = Current > second
     */
    @Override
    public int compareTo(Value value) {
        if (this.getPosition() == value.getPosition()) {
            return 0;
        } else if (this.getPosition() > value.getPosition()) {
            return 1;
        } else {
            return -1;
        }
    }
}