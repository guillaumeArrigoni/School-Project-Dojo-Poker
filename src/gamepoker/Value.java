package gamepoker;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * The value of the cards depends on the strength of each card, this is one of the rules of classic poker.
 * There is a hierarchy of cards that determines strength in poker.
 * The best card is the Ace and the worst is the 2, among the 13 of each suit.
 *
 * @author Karim CHARLEUX & Yacine MERIOUA
 */
public class Value {

    public static final Value DEUX = new Value("2");
    public static final Value TROIS = new Value("3");
    public static final Value QUATRE = new Value("4");
    public static final Value CINQ = new Value("5");
    public static final Value SIX = new Value("6");
    public static final Value SEPT = new Value("7");
    public static final Value HUIT = new Value("8");
    public static final Value NEUF = new Value("9");
    public static final Value DIX = new Value("10");
    public static final Value VALET = new Value("V");
    public static final Value DAME = new Value("D");
    public static final Value ROI = new Value("R");
    public static final Value AS = new Value("A");

    /**
     * The name of the value
     */
    private final String name;

    /**
     * Create a value card with a name
     *
     * @param name of the value object
     */
    public Value(String name) {
        this.name = name;
        //TODO: Create an exception if name is not correct
    }

    /**
     * Create a value card with a position between 2-14
     *
     * @param position a int between 2-14
     */
    public Value(int position) {
        //Get name corresponding to the position in AllValues array
        this.name = getAllValues().get(position).getName();
        //TODO: Create an exception if position is not correct (2-14)
    }

    /**
     * @return The name of current value object
     */
    public String getName() {
        return this.name;
    }

    /**
     * Get the position of the value between 2 and 14 to determine the highest to the lowest value
     *
     * @return The position of current value
     */
    public int getPosition() {
        List<Value> allValues = getAllValues();
        for (int position = 2; position <= allValues.size(); position++) {
            if (allValues.get(position).getName().equals(this.name))
                return position;
        }
        return -1; //TODO: Create an exception here
    }

    /**
     * Overriding equals() to compare two Value objects
     *
     * @param object The Value object to compare to the current Value
     * @return False or true if object is equals to current Value
     */
    @Override
    public boolean equals(Object object) {
        // If the object is compared with itself then return true
        if (object == this) {
            return true;
        }
        // Check if object is an instance of Value or not
        if (!(object instanceof Value)) {
            return false;
        }
        // Typecast object to Value so that we can compare both data
        Value value2 = (Value) object;

        // Compare the data members and return accordingly
        return value2.name.equals(this.name) && value2.getPosition() == this.getPosition();
    }

    /**
     * Convert a value object in a string object to correct display
     *
     * @return the value converted to a string
     */
    @Override
    public String toString() {
        return this.name;
    }

    /**
     * Give all possible values of a card in an array
     *
     * @return an ArrayList of all values
     */
    public static List<Value> getAllValues() {
        return new ArrayList<>(Arrays.asList(null, null, DEUX, TROIS, QUATRE, CINQ, SIX, SEPT, HUIT, NEUF, DIX, VALET, DAME, ROI, AS));
    }

    /**
     * @return a unique integer value, generated by a hashing algorithm according to name
     */
    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}